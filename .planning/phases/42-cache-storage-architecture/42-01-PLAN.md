---
phase: 42-cache-storage-architecture
plan: 01
type: execute
---

<objective>
Design and implement browser storage layer for widget data caching.

Purpose: Create a unified cache abstraction that widgets can use to store and retrieve data, enabling instant rendering on subsequent page loads while fresh data loads in the background.

Output: Widget cache utility module with TypeScript interfaces, localStorage-based storage, versioning support, and comprehensive error handling for quota exceeded and storage unavailable scenarios.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior work:**
- Phases 29-34: Built scraper-to-EC2 sync infrastructure with versioned storage
- Existing pattern: src/utils/insights-cache.ts shows localStorage usage for AI-generated insights

**Existing pattern to extend:**
@src/utils/insights-cache.ts

**Widget data fetching patterns:**
@src/components/a2ui/AnthropicUsageCard.tsx (lines 100-140 show fetch-on-mount pattern)

**Tech stack available:**
- TypeScript with strict mode
- React 18 with hooks
- Browser localStorage API (5-10MB limit)
- Existing insights-cache.ts as pattern reference

**Established patterns:**
- Cache versioning with automatic reset on version mismatch
- Try/catch wrappers for all localStorage operations
- Timestamp tracking for cache entries
- Component ID-based cache keys

**Design decisions:**
- Use localStorage (not IndexedDB) for simplicity - follows insights-cache.ts pattern
- Cache key structure: widget-type:data-hash for deduplication
- Version cache entries to handle schema changes automatically
- Error handling: Fail gracefully on quota exceeded, return null on read errors

**Why localStorage over IndexedDB:**
- Simpler synchronous API (no async complexity in render path)
- 5-10MB sufficient for widget data (JSON responses ~5-50KB each)
- insights-cache.ts already proves localStorage works for this use case
- Easier debugging (Chrome DevTools → Application → Local Storage)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Design cache storage architecture and TypeScript interfaces</name>
  <files>src/utils/widget-cache.ts</files>
  <action>
Create widget-cache.ts module extending the insights-cache.ts pattern to support all widget types.

**TypeScript interfaces:**
```typescript
interface WidgetCacheEntry<T = unknown> {
  data: T;
  timestamp: number;
  version: number;
  widgetType: string;
}

interface WidgetCache {
  version: number;
  entries: Record<string, WidgetCacheEntry>;
}
```

**Cache key structure:**
- Format: `{widgetType}:{cacheKey}`
- Example: `anthropic-usage:api-tokens`, `aws-costs:monthly-summary`
- Allows multiple cache entries per widget type (different queries/timeframes)

**Storage constants:**
- CACHE_KEY = 'widget-cache-v1'
- CACHE_VERSION = 1
- Use separate localStorage key from insights-cache to avoid conflicts

**Why this structure:**
- Generic `<T>` allows type-safe cache operations per widget
- widgetType field enables selective invalidation by widget
- Timestamp for staleness detection (Phase 46 will use this)
- Version for automatic schema migration (reset cache on version bump)
- Record<string, WidgetCacheEntry> allows multiple cache entries (vs insights-cache's single entry per component)
  </action>
  <verify>TypeScript compiles without errors, interfaces are exported</verify>
  <done>widget-cache.ts file created with complete type definitions matching plan structure</done>
</task>

<task type="auto">
  <name>Task 2: Implement core cache operations (get, set, delete, clear)</name>
  <files>src/utils/widget-cache.ts</files>
  <action>
Implement cache operations following insights-cache.ts error handling pattern.

**getCache() - Internal helper:**
- Read localStorage.getItem('widget-cache-v1')
- Parse JSON, handle errors → return empty cache
- Check version mismatch → reset to empty cache
- Return WidgetCache object

**saveCache(cache: WidgetCache) - Internal helper:**
- JSON.stringify and localStorage.setItem
- Wrap in try/catch, silently ignore quota exceeded (Phase 47 will handle this)
- No return value needed

**getCachedWidget<T>(widgetType: string, cacheKey: string): WidgetCacheEntry<T> | null - Public API:**
- Call getCache(), lookup `entries[${widgetType}:${cacheKey}]`
- Return entry if exists, null if missing
- Type parameter T allows caller to specify expected data type
- Example: `getCachedWidget<ApiTokenUsage>('anthropic-usage', 'api-tokens')`

**setCachedWidget<T>(widgetType: string, cacheKey: string, data: T): void - Public API:**
- Call getCache(), add/update entry with current timestamp and CACHE_VERSION
- Call saveCache() to persist
- Silently ignore storage errors (graceful degradation)

**deleteCachedWidget(widgetType: string, cacheKey: string): void - Public API:**
- Call getCache(), delete `entries[${widgetType}:${cacheKey}]`
- Call saveCache() to persist

**clearWidgetCache(): void - Public API:**
- localStorage.removeItem('widget-cache-v1')
- For debugging and force refresh scenarios

**Error handling:**
- All localStorage operations in try/catch
- Parse errors → return empty cache (don't crash)
- Quota exceeded → ignore (Phase 47 will add quota management)
- Never throw exceptions to caller
  </action>
  <verify>
- TypeScript compiles without errors
- All functions exported
- Try/catch wraps all localStorage calls
- Test manually in Chrome DevTools console:
  ```javascript
  import { setCachedWidget, getCachedWidget } from './src/utils/widget-cache';
  setCachedWidget('test', 'key1', { value: 123 });
  getCachedWidget('test', 'key1'); // Should return entry with data: { value: 123 }
  ```
  </verify>
  <done>All cache operations implemented with error handling, exports verified, manual test passes in DevTools</done>
</task>

<task type="auto">
  <name>Task 3: Add cache utilities for staleness detection and pruning</name>
  <files>src/utils/widget-cache.ts</files>
  <action>
Add utility functions extending the insights-cache.ts pruneStaleCache pattern.

**isCacheStale(entry: WidgetCacheEntry, maxAgeMs: number): boolean:**
- Return `Date.now() - entry.timestamp > maxAgeMs`
- Used by widgets to show staleness indicators (Phase 43)
- Example: `isCacheStale(entry, 5 * 60 * 1000)` checks if older than 5 minutes

**getCacheAge(entry: WidgetCacheEntry): number:**
- Return `Date.now() - entry.timestamp` (age in milliseconds)
- Useful for displaying "Updated X minutes ago"

**pruneStaleWidgetCache(maxAgeHours: number = 24): void:**
- Follow insights-cache.ts pattern exactly
- Call getCache(), iterate entries, delete if timestamp > maxAge
- Call saveCache() only if entries were deleted
- Run automatically on app startup (Phase 43 will add this)

**clearWidgetCacheByType(widgetType: string): void:**
- Delete all entries matching widgetType prefix
- Example: `clearWidgetCacheByType('aws-costs')` removes all AWS cost cache entries
- Useful for selective invalidation

**Why these utilities:**
- isCacheStale enables conditional rendering (show warning banner if stale)
- getCacheAge for user-facing "last updated" timestamps
- pruneStaleWidgetCache prevents cache bloat (follows insights-cache pattern)
- clearWidgetCacheByType for widget-specific refresh (force reload one widget type)
  </action>
  <verify>
- TypeScript compiles without errors
- All utility functions exported
- Test staleness detection:
  ```javascript
  const entry = { timestamp: Date.now() - 10 * 60 * 1000 }; // 10 min old
  isCacheStale(entry, 5 * 60 * 1000); // true (older than 5 min)
  getCacheAge(entry); // ~600000ms (10 minutes)
  ```
  </verify>
  <done>Utility functions implemented, tested, and exported. Ready for Phase 43 widget integration.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] TypeScript compilation passes (`npm run build` or `tsc --noEmit`)
- [ ] No new TypeScript errors introduced
- [ ] All exports present: getCachedWidget, setCachedWidget, deleteCachedWidget, clearWidgetCache, isCacheStale, getCacheAge, pruneStaleWidgetCache, clearWidgetCacheByType
- [ ] Manual localStorage test in Chrome DevTools confirms cache operations work
- [ ] File follows existing code style (matches insights-cache.ts patterns)
</verification>

<success_criteria>

- widget-cache.ts module created with complete implementation
- All TypeScript interfaces defined and exported
- Core operations (get, set, delete, clear) implemented with error handling
- Utility functions for staleness detection and pruning
- Follows insights-cache.ts patterns (version checking, try/catch, silent errors)
- No TypeScript compilation errors
- Module ready for Phase 43 widget integration
  </success_criteria>

<output>
After completion, create `.planning/phases/42-cache-storage-architecture/42-01-SUMMARY.md`:

# Phase 42 Plan 1: Cache Storage Architecture Summary

**[One-liner describing what shipped]**

## Accomplishments

- Created widget-cache.ts module with TypeScript interfaces
- Implemented localStorage-based cache operations
- Added versioning and staleness detection utilities
- Error handling for quota exceeded and parse errors

## Files Created/Modified

- `src/utils/widget-cache.ts` - New cache storage module

## Decisions Made

- **localStorage over IndexedDB**: Simpler API, sufficient capacity (5-10MB), matches insights-cache.ts pattern
- **Cache key structure**: `{widgetType}:{cacheKey}` for flexible multi-entry support per widget
- **Silent error handling**: All localStorage errors caught and ignored (graceful degradation)
- **Version-based invalidation**: Auto-reset cache on version mismatch

## Issues Encountered

[Any problems and resolutions, or "None"]

## Next Phase Readiness

Phase 42 complete (1/1 plans). Ready for Phase 43 (Widget Cache Hydration Layer).

Widget integration needs:
- Import getCachedWidget on component mount
- Display cached data immediately if available
- Show staleness indicator if cache is old
- Trigger background fetch after displaying cache
</output>
