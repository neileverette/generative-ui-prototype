---
phase: 40-chat-routing-integration
type: execute
---

<objective>
Connect chat input to the utterance routing system to enable chat messages to drive widget loading directly.

Purpose: Make chat utterances the primary driver of widget composition. When users type utterances that match routing patterns (e.g., "show automations", "system metrics", "costs"), the system should route them through the utterance router first, load widgets immediately, and optionally provide text responses. This replaces the current flow where chat goes directly to CopilotKit.

Output: Chat messages route through the utterance-router before CopilotKit, widgets load immediately on route matches, conversational fallback for non-matching utterances.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/services/utterance-router.ts
@src/hooks/useWidgetLoader.ts
@src/App.tsx
@src/config/widget-routing.json

**Current Architecture:**
- Chat messages go directly to CopilotKit via `appendMessage()`
- CopilotKit actions (useCopilotAction) like `fetchSystemMetrics`, `fetchCostsOverview` handle widget loading
- Navigation cards successfully use `processUtterance()` from useWidgetLoader
- Voice input also goes directly to chat via `appendMessage()`

**Available Components:**
- `routeUtterance(utterance: string): RouteMatch | null` - Core routing engine (40% confidence threshold)
- `useWidgetLoader` hook with `processUtterance()` - Handles routing + lifecycle
- Widget routing config with routes, keywords, patterns, questionPatterns
- RouteMatch includes: routeId, displayName, view, action, widgets, confidence, matchType

**Key Files:**
- src/App.tsx - Contains handleSendMessage, handleVoiceTranscriptComplete, all useCopilotAction handlers
- src/hooks/useWidgetLoader.ts - Widget loading lifecycle with onRouteMatch/onRouteNotFound callbacks
- src/services/utterance-router.ts - Pattern matching and routing engine

**Established Patterns:**
- Navigation cards call `handleNavigate()` → `processUtterance()` → routes successfully
- Widget loader clears previous widgets, switches views, loads new widgets
- CopilotKit actions have specific handlers for each route (fetchSystemMetrics, fetchCostsOverview, etc.)

**Constraining Decisions:**
- Phase 35-39 established the routing architecture and widget loading patterns
- Routing confidence threshold is 40% (anything below falls back to chat)
- Widget groups are defined in widget-routing.json with action names matching CopilotKit actions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Intercept chat messages before CopilotKit</name>
  <files>src/App.tsx</files>
  <action>
  Modify `handleSendMessage` and `handleVoiceTranscriptComplete` to route messages through the utterance router BEFORE sending to CopilotKit.

  **Flow:**
  1. User sends message or voice completes → call `processUtterance(message)` from useWidgetLoader
  2. If route matches (confidence >= 40%):
     - Widget loader handles loading (it already does this via onRouteMatch callback)
     - Do NOT send to CopilotKit (widgets appear immediately, no LLM needed)
     - Return early
  3. If no route match (confidence < 40%):
     - Fall back to sending to CopilotKit via `appendMessage()` for conversational response
     - This preserves existing chat behavior for questions like "how do I configure this?"

  **Implementation approach:**
  - Create a wrapper function `handleChatInput(message: string)` that handles routing logic
  - Call routeUtterance() to check for matches
  - If match.confidence >= 40, call processUtterance() and return
  - If no match, call appendMessage() to send to CopilotKit
  - Update both handleSendMessage and handleVoiceTranscriptComplete to use this wrapper

  **What to avoid:**
  - Don't modify processUtterance() - it already handles routing correctly
  - Don't remove CopilotKit integration - it's the fallback for non-matching utterances
  - Don't break the voice input flow - it should work the same way
  </action>
  <verify>
  1. Test chat input with routing patterns: "show costs", "system metrics", "automations"
  2. Verify widgets load immediately without waiting for LLM response
  3. Test non-matching chat: "how do I configure this?" should go to CopilotKit
  4. Verify voice input works the same way (routes first, falls back to chat)
  5. Check console logs show routing decisions: "[WidgetLoader] Route matched" or "[WidgetLoader] No route found"
  </verify>
  <done>
  - Chat messages matching routing patterns (confidence >= 40%) load widgets immediately via processUtterance()
  - Non-matching messages fall back to CopilotKit for conversational responses
  - Voice input follows same routing logic as text chat
  - Console logs clearly show routing vs fallback decisions
  </done>
</task>

<task type="auto">
  <name>Task 2: Handle CopilotKit action deduplication</name>
  <files>src/App.tsx</files>
  <action>
  Now that chat routes through utterance-router first, CopilotKit actions become redundant for most cases. However, we need to keep them for:
  1. Edge cases where LLM decides to call them directly (semantic understanding)
  2. Complex queries that might benefit from LLM interpretation

  **Modify CopilotKit actions to detect and prevent duplicate widget loading:**

  For each action handler (fetchSystemMetrics, fetchCostsOverview, fetchAutomations, etc.):
  - Check if widgets are already loaded (currentView === 'home' && widgets exist)
  - If widgets already loaded from routing, return early with message "Already showing [X]"
  - If not loaded, execute the action as normal (keeps existing behavior)

  **Why:**
  - Prevents race conditions where routing loads widgets AND CopilotKit action tries to load them
  - Allows LLM to still call actions if needed (complex semantic queries)
  - Maintains backward compatibility

  **Implementation:**
  - Add a helper function `isWidgetTypeLoaded(widgetPrefix: string): boolean`
  - Check dashboardState.components for widgets with matching ID prefix
  - Return early from action handlers if widgets already loaded
  - Keep all the data fetching logic (might be useful for refresh scenarios)

  **What to avoid:**
  - Don't remove CopilotKit actions entirely - they're still useful for semantic understanding
  - Don't break the existing renderDashboard/addComponent actions - they're generic utilities
  - Don't modify widget IDs - they're used for deduplication
  </action>
  <verify>
  1. Type "show costs" in chat → widgets load via routing
  2. Verify CopilotKit doesn't try to load costs again (check for duplicate widgets)
  3. Test complex query: "what are my most expensive AWS services?" → LLM might use fetchCostsOverview directly
  4. Check console for duplicate loading attempts
  5. Verify no TypeScript errors
  </verify>
  <done>
  - CopilotKit actions detect when widgets are already loaded from routing
  - Actions return early with "Already showing [X]" message if widgets exist
  - Complex semantic queries can still trigger actions if routing doesn't match
  - No duplicate widgets appear in dashboard
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Chat-to-routing integration with immediate widget loading and conversational fallback</what-built>
  <how-to-verify>
    1. Run: `npm run dev` (if not already running)
    2. Open: http://localhost:3000
    3. Test routing patterns (should load widgets immediately):
       - Type: "show costs" → AWS costs widgets appear instantly
       - Type: "system metrics" → System metrics cards appear instantly
       - Type: "show automations" → Automation workflow widgets appear instantly
       - Type: "containers" → Container list and metrics appear instantly
    4. Test fallback to chat (should get conversational responses):
       - Type: "how do I configure automations?" → Get a text response, not widgets
       - Type: "what is the weather?" → Get conversational response
    5. Test voice input:
       - Click voice button
       - Say: "show deployments" → Should route and load widgets
       - Say: "tell me about the system" → Should fall back to chat
    6. Test edge cases:
       - Type "show costs" twice → Second time should say "Already showing costs"
       - Clear dashboard, type "costs" → Should load widgets
    7. Check console logs:
       - Look for: "[WidgetLoader] Route matched" when routing succeeds
       - Look for: "[WidgetLoader] No route found, falling back to chat" when no match
       - Verify no errors or warnings
    8. Verify widgets appear WITHOUT waiting for LLM response
       - Widgets should load immediately (within 100-200ms)
       - No "thinking" indicator before widgets appear
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe any issues (widgets not loading, chat broken, voice broken, etc.)</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Chat messages matching routing patterns load widgets immediately
- [ ] Non-matching messages fall back to CopilotKit for conversational responses
- [ ] Voice input follows same routing logic
- [ ] CopilotKit actions detect and prevent duplicate widget loading
- [ ] No TypeScript errors or build warnings
- [ ] Console logs show routing decisions clearly
- [ ] Widgets appear within 200ms (no LLM wait)
</verification>

<success_criteria>

- All tasks completed
- Chat input routes through utterance-router before CopilotKit
- Matching utterances (confidence >= 40%) load widgets immediately via processUtterance()
- Non-matching utterances fall back to CopilotKit for conversational responses
- Voice input follows same routing logic as text chat
- CopilotKit actions prevent duplicate widget loading
- User verification confirms widgets load instantly for routing patterns
- Console logs clearly show routing vs fallback decisions
- No errors or warnings in build or runtime
</success_criteria>

<output>
After completion, create `.planning/phases/40-chat-routing-integration/40-01-SUMMARY.md`:

# Phase 40 Plan 1: Chat-to-Routing Integration Summary

**Chat input now routes through utterance-router first, loading widgets immediately for matching patterns and falling back to CopilotKit for conversational queries.**

## Accomplishments

- Chat messages route through utterance-router before CopilotKit
- Matching utterances load widgets immediately (no LLM wait)
- Non-matching utterances fall back to conversational responses
- Voice input follows same routing logic
- CopilotKit actions prevent duplicate widget loading

## Files Created/Modified

- `src/App.tsx` - Added chat input routing wrapper, modified CopilotKit action handlers

## Decisions Made

- Routing confidence threshold: 40% (route matches) vs < 40% (fallback to chat)
- CopilotKit actions kept for semantic understanding and edge cases
- Voice input follows same routing logic as text chat

## Issues Encountered

[Document any issues or resolutions]

## Next Phase Readiness

Phase 40 complete. Ready for Phase 41 (Testing & Edge Cases).
</output>
