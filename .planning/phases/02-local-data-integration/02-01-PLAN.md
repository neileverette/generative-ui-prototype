# Plan: Phase 2 - Local Data Integration

## Objective

Connect the ClaudeUsageCard component to real Claude Code usage data by creating a backend endpoint that parses JSONL files from `~/.claude/projects/`, calculates token usage within a 5-hour rolling window, aggregates usage by model, and transforms the data to match the widget's interface.

## Execution Context

**Files to reference:**
- `server/index.ts` - Express backend patterns (see AWS costs, ECR endpoints)
- `src/services/mcp-client.ts` - Frontend service pattern for API calls
- `src/types/claude-usage.ts` - TypeScript interfaces for usage data
- `src/config/claude-usage.config.ts` - Pricing and threshold configuration
- `src/components/a2ui/ClaudeUsageCard.tsx` - Widget consuming the data

**Data sources discovered:**
- `~/.claude/projects/{project-path}/` - Contains JSONL session files
- `~/.claude/projects/{project-path}/sessions-index.json` - Session metadata
- JSONL entries with `message.usage` containing token counts

**JSONL Schema (from research):**
```typescript
interface JournalEntry {
  type: 'user' | 'assistant' | 'summary' | 'progress' | 'file-history-snapshot';
  timestamp: string;  // ISO timestamp
  sessionId: string;
  message?: {
    model?: string;  // e.g., 'claude-opus-4-5-20251101'
    usage?: {
      input_tokens: number;
      output_tokens: number;
      cache_creation_input_tokens?: number;
      cache_read_input_tokens?: number;
    };
  };
}
```

**Key patterns to follow:**
- Backend endpoints use async/await with try/catch
- Responses include `queriedAt` timestamp and `source` field
- MCP client methods follow `get{Resource}()` naming convention
- Token usage aggregation across JSONL files

## Context

This is Phase 2 of 4 for the Claude Usage Widget feature. Phase 1 created the visual component with mock data. Phase 2 connects it to real data.

**5-Hour Window Calculation:**
- Claude Code resets usage every 5 hours
- Need to find entries within the last 5 hours from current time
- Calculate total tokens used in that window
- Estimate reset time based on first entry in window

**Token Counting Strategy:**
1. Scan all JSONL files in the current project directory
2. Filter entries with `type: 'assistant'` and `message.usage`
3. Sum `input_tokens + output_tokens` for total tokens
4. Group by model name for breakdown
5. Use timestamp to filter to 5-hour window

**Cost Estimation:**
- Use pricing from `claude-usage.config.ts`
- Apply per-model rates for input/output tokens
- Cache tokens typically charged at 1/10 rate (for display purposes, treat as regular tokens)

## Tasks

### Task 1: Create JSONL parsing utilities
**File:** `server/claude-usage.ts` (NEW)

Create utilities for parsing Claude Code JSONL files:

```typescript
import fs from 'fs';
import path from 'path';
import readline from 'readline';

// Types for JSONL entries
interface UsageEntry {
  timestamp: string;
  model: string;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
}

interface SessionIndex {
  version: number;
  entries: Array<{
    sessionId: string;
    fullPath: string;
    created: string;
    modified: string;
    messageCount: number;
  }>;
}

// Get Claude projects directory path
export function getClaudeProjectsDir(): string {
  const homeDir = process.env.HOME || process.env.USERPROFILE || '';
  return path.join(homeDir, '.claude', 'projects');
}

// Convert project path to Claude directory name format
// e.g., /Users/neil/Desktop/myproject -> -Users-neil-Desktop-myproject
export function projectPathToDirName(projectPath: string): string {
  return projectPath.replace(/\//g, '-').replace(/^-/, '');
}

// Parse a single JSONL file for usage entries
export async function parseJSONLFile(filePath: string): Promise<UsageEntry[]> {
  const entries: UsageEntry[] = [];

  if (!fs.existsSync(filePath)) {
    return entries;
  }

  const fileStream = fs.createReadStream(filePath);
  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity
  });

  for await (const line of rl) {
    try {
      const data = JSON.parse(line);

      // Only process assistant messages with usage data
      if (data.type === 'assistant' && data.message?.usage) {
        const usage = data.message.usage;
        entries.push({
          timestamp: data.timestamp,
          model: data.message.model || 'unknown',
          inputTokens: usage.input_tokens || 0,
          outputTokens: usage.output_tokens || 0,
          cacheCreationTokens: usage.cache_creation_input_tokens || 0,
          cacheReadTokens: usage.cache_read_input_tokens || 0,
        });
      }
    } catch (e) {
      // Skip malformed lines
    }
  }

  return entries;
}

// Get all JSONL files for a project
export function getProjectJSONLFiles(projectDirName: string): string[] {
  const projectsDir = getClaudeProjectsDir();
  const projectDir = path.join(projectsDir, projectDirName);

  if (!fs.existsSync(projectDir)) {
    return [];
  }

  return fs.readdirSync(projectDir)
    .filter(f => f.endsWith('.jsonl') && !f.startsWith('agent-'))
    .map(f => path.join(projectDir, f));
}
```

**Verification:** Import and call `getClaudeProjectsDir()` - should return valid path.

---

### Task 2: Create 5-hour window calculation logic
**File:** `server/claude-usage.ts` (APPEND)

Add functions to calculate usage within the 5-hour rolling window:

```typescript
import { CLAUDE_USAGE_CONFIG, getUsageStatus } from '../src/config/claude-usage.config.js';

// Filter entries to last 5 hours
export function filterToFiveHourWindow(entries: UsageEntry[]): UsageEntry[] {
  const fiveHoursAgo = Date.now() - (5 * 60 * 60 * 1000);
  return entries.filter(e => new Date(e.timestamp).getTime() >= fiveHoursAgo);
}

// Calculate when the 5-hour window resets
export function calculateResetTime(windowEntries: UsageEntry[]): { resetsAt: string; resetsIn: string } {
  if (windowEntries.length === 0) {
    // If no entries, window resets in 5 hours from now
    const resetsAt = new Date(Date.now() + 5 * 60 * 60 * 1000);
    return {
      resetsAt: resetsAt.toISOString(),
      resetsIn: '5h 0m',
    };
  }

  // Find the oldest entry in the window
  const timestamps = windowEntries.map(e => new Date(e.timestamp).getTime());
  const oldestEntry = Math.min(...timestamps);

  // Window resets 5 hours after the oldest entry
  const resetsAt = new Date(oldestEntry + 5 * 60 * 60 * 1000);
  const msUntilReset = resetsAt.getTime() - Date.now();

  if (msUntilReset <= 0) {
    // Window has already reset, calculate new reset time
    return calculateResetTime([]);
  }

  const hours = Math.floor(msUntilReset / (60 * 60 * 1000));
  const minutes = Math.floor((msUntilReset % (60 * 60 * 1000)) / (60 * 1000));

  return {
    resetsAt: resetsAt.toISOString(),
    resetsIn: `${hours}h ${minutes}m`,
  };
}

// Aggregate usage by model
export function aggregateByModel(entries: UsageEntry[]): Map<string, { tokens: number; inputTokens: number; outputTokens: number }> {
  const modelUsage = new Map<string, { tokens: number; inputTokens: number; outputTokens: number }>();

  for (const entry of entries) {
    // Normalize model name (e.g., 'claude-opus-4-5-20251101' -> 'opus')
    const modelKey = normalizeModelName(entry.model);

    const existing = modelUsage.get(modelKey) || { tokens: 0, inputTokens: 0, outputTokens: 0 };
    const totalTokens = entry.inputTokens + entry.outputTokens + entry.cacheCreationTokens + entry.cacheReadTokens;

    modelUsage.set(modelKey, {
      tokens: existing.tokens + totalTokens,
      inputTokens: existing.inputTokens + entry.inputTokens + entry.cacheCreationTokens + entry.cacheReadTokens,
      outputTokens: existing.outputTokens + entry.outputTokens,
    });
  }

  return modelUsage;
}

// Normalize model identifier to short name
export function normalizeModelName(model: string): string {
  const lower = model.toLowerCase();
  if (lower.includes('opus')) return 'opus';
  if (lower.includes('sonnet')) return 'sonnet';
  if (lower.includes('haiku')) return 'haiku';
  return 'other';
}

// Estimate cost based on token usage
export function estimateCost(inputTokens: number, outputTokens: number, model: string): number {
  const pricing = CLAUDE_USAGE_CONFIG.pricing;

  // Find matching pricing
  let priceKey = Object.keys(pricing).find(k => model.includes(k.split('-')[1] || ''));
  if (!priceKey) priceKey = 'claude-3-sonnet'; // Default

  const rates = pricing[priceKey as keyof typeof pricing];
  const inputCost = (inputTokens / 1_000_000) * rates.input;
  const outputCost = (outputTokens / 1_000_000) * rates.output;

  return inputCost + outputCost;
}
```

**Verification:** Unit test `filterToFiveHourWindow` with mock entries.

---

### Task 3: Create the main data aggregation function
**File:** `server/claude-usage.ts` (APPEND)

Create the main function that builds the ClaudeCodeUsage response:

```typescript
import type { ClaudeCodeUsage, ClaudePlanTier, ModelUsage } from '../src/types/claude-usage.js';

interface AggregatedUsage {
  fiveHourWindow: {
    used: number;
    limit: number;
    percentage: number;
    resetsAt: string;
    resetsIn: string;
  };
  today: {
    tokens: number;
    estimatedCost: number;
    sessions: number;
  };
  monthToDate: {
    tokens: number;
    estimatedCost: number;
    sessions: number;
  };
  modelBreakdown: ModelUsage[];
}

// Get usage for a specific project directory
export async function getClaudeCodeUsage(
  projectPath: string,
  plan: ClaudePlanTier = 'pro'
): Promise<ClaudeCodeUsage> {
  const projectDirName = projectPathToDirName(projectPath);
  const jsonlFiles = getProjectJSONLFiles(projectDirName);

  // Parse all JSONL files
  const allEntries: UsageEntry[] = [];
  for (const file of jsonlFiles) {
    const entries = await parseJSONLFile(file);
    allEntries.push(...entries);
  }

  // Sort by timestamp
  allEntries.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

  // Calculate 5-hour window
  const windowEntries = filterToFiveHourWindow(allEntries);
  const windowTokens = windowEntries.reduce((sum, e) =>
    sum + e.inputTokens + e.outputTokens + e.cacheCreationTokens + e.cacheReadTokens, 0
  );
  const planLimit = CLAUDE_USAGE_CONFIG.planLimits[plan];
  const windowPercentage = Math.min(100, (windowTokens / planLimit) * 100);
  const resetInfo = calculateResetTime(windowEntries);

  // Calculate today's usage
  const todayStart = new Date();
  todayStart.setHours(0, 0, 0, 0);
  const todayEntries = allEntries.filter(e => new Date(e.timestamp) >= todayStart);
  const todayTokens = todayEntries.reduce((sum, e) =>
    sum + e.inputTokens + e.outputTokens + e.cacheCreationTokens + e.cacheReadTokens, 0
  );
  const todaySessions = new Set(jsonlFiles.filter(f => {
    const stat = fs.statSync(f);
    return stat.mtime >= todayStart;
  })).size;

  // Calculate MTD usage
  const monthStart = new Date();
  monthStart.setDate(1);
  monthStart.setHours(0, 0, 0, 0);
  const mtdEntries = allEntries.filter(e => new Date(e.timestamp) >= monthStart);
  const mtdTokens = mtdEntries.reduce((sum, e) =>
    sum + e.inputTokens + e.outputTokens + e.cacheCreationTokens + e.cacheReadTokens, 0
  );

  // Calculate model breakdown (today)
  const modelAgg = aggregateByModel(todayEntries);
  const totalTodayCost = Array.from(modelAgg.entries()).reduce((sum, [model, usage]) =>
    sum + estimateCost(usage.inputTokens, usage.outputTokens, model), 0
  );

  const modelBreakdown: ModelUsage[] = Array.from(modelAgg.entries())
    .map(([model, usage]) => ({
      model: model as 'opus' | 'sonnet' | 'haiku',
      tokens: usage.tokens,
      cost: estimateCost(usage.inputTokens, usage.outputTokens, model),
      percentage: todayTokens > 0 ? (usage.tokens / todayTokens) * 100 : 0,
    }))
    .filter(m => m.tokens > 0)
    .sort((a, b) => b.tokens - a.tokens);

  // Calculate MTD cost
  const mtdModelAgg = aggregateByModel(mtdEntries);
  const mtdCost = Array.from(mtdModelAgg.entries()).reduce((sum, [model, usage]) =>
    sum + estimateCost(usage.inputTokens, usage.outputTokens, model), 0
  );

  return {
    plan,
    fiveHourWindow: {
      used: windowTokens,
      limit: planLimit,
      percentage: parseFloat(windowPercentage.toFixed(1)),
      resetsAt: resetInfo.resetsAt,
      resetsIn: resetInfo.resetsIn,
    },
    today: {
      tokens: todayTokens,
      estimatedCost: parseFloat(totalTodayCost.toFixed(2)),
      sessions: todaySessions,
    },
    monthToDate: {
      tokens: mtdTokens,
      estimatedCost: parseFloat(mtdCost.toFixed(2)),
      sessions: jsonlFiles.length,
    },
    modelBreakdown,
    lastUpdated: new Date().toISOString(),
    dataSource: 'local-files',
  };
}
```

**Verification:** Call function with current project path, verify returned structure.

---

### Task 4: Create backend API endpoint
**File:** `server/index.ts` (MODIFY)

Add the `/api/claude-usage/code` endpoint:

```typescript
// Add import at top
import { getClaudeCodeUsage } from './claude-usage.js';

// Add endpoint after existing API endpoints (around line 1743, after /api/costs/overview)

// =============================================================================
// CLAUDE USAGE ENDPOINTS
// =============================================================================

// Get Claude Code usage for current project
app.get('/api/claude-usage/code', async (req, res) => {
  try {
    // Get current project path from query or use default
    const projectPath = (req.query.projectPath as string) || process.cwd();
    const plan = (req.query.plan as string) || 'pro';

    // Validate plan
    const validPlans = ['free', 'pro', 'max5', 'max20'];
    if (!validPlans.includes(plan)) {
      return res.status(400).json({
        error: `Invalid plan. Must be one of: ${validPlans.join(', ')}`
      });
    }

    const usage = await getClaudeCodeUsage(
      projectPath,
      plan as 'free' | 'pro' | 'max5' | 'max20'
    );

    res.json({
      ...usage,
      queriedAt: new Date().toISOString(),
      source: 'local-jsonl',
    });
  } catch (error) {
    console.error('[Claude Usage] Error:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Unknown error',
      source: 'claude-usage',
    });
  }
});
```

**Verification:** `curl http://localhost:4000/api/claude-usage/code` returns valid response.

---

### Task 5: Add method to MCP client
**File:** `src/services/mcp-client.ts` (MODIFY)

Add the `getClaudeCodeUsage` method to the MCPClient class:

```typescript
// Add import at top (if not present)
import { ClaudeCodeUsage, ClaudePlanTier } from '../types/claude-usage';

// Add method to MCPClient class (after existing methods, around line 335)

// ==========================================================================
// Claude Usage Methods
// ==========================================================================

/**
 * Get Claude Code usage data from local JSONL files
 * Uses direct API endpoint (no MCP tool yet)
 */
async getClaudeCodeUsage(
  projectPath?: string,
  plan: ClaudePlanTier = 'pro'
): Promise<ClaudeCodeUsage & { queriedAt: string }> {
  console.log('[MCP Client] getClaudeCodeUsage via direct API');

  const params = new URLSearchParams();
  if (projectPath) params.append('projectPath', projectPath);
  params.append('plan', plan);

  const url = `${this.directBaseUrl}/claude-usage/code${params.toString() ? '?' + params.toString() : ''}`;
  const response = await fetch(url);

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: response.statusText }));
    throw new Error(error.error || `Failed to fetch Claude usage: ${response.statusText}`);
  }

  return response.json();
}
```

**Verification:** Import and call from component, verify data loads.

---

### Task 6: Connect widget to real data
**File:** `src/components/a2ui/ClaudeUsageCard.tsx` (MODIFY)

Update the component to fetch real data:

1. Add state hooks and useEffect for data fetching:

```typescript
// Add at top of file
import { useState, useEffect } from 'react';
import { mcpClient } from '../../services/mcp-client';

// In ClaudeUsageCard component, before the return statement:
export function ClaudeUsageCard({
  component,
  className,
}: ClaudeUsageCardComponentProps) {
  const { props } = component;
  const { showApiSection = true } = props;

  // State for real data
  const [claudeCode, setClaudeCode] = useState<ClaudeCodeUsage | null>(props.claudeCode);
  const [apiCredits, setApiCredits] = useState<ApiCreditsUsage | null>(props.apiCredits);
  const [isLoading, setIsLoading] = useState(!props.claudeCode);
  const [error, setError] = useState<string | null>(null);

  // Fetch real data on mount
  useEffect(() => {
    async function fetchData() {
      // Skip if data was provided via props
      if (props.claudeCode) return;

      setIsLoading(true);
      setError(null);

      try {
        const usage = await mcpClient.getClaudeCodeUsage();
        setClaudeCode(usage);
      } catch (err) {
        console.error('[ClaudeUsageCard] Error fetching data:', err);
        setError(err instanceof Error ? err.message : 'Failed to load usage data');
        // Fall back to mock data on error
        setClaudeCode(MOCK_CLAUDE_CODE_USAGE);
      } finally {
        setIsLoading(false);
      }
    }

    fetchData();

    // Refresh every 5 minutes
    const interval = setInterval(fetchData, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [props.claudeCode]);

  const status = claudeCode
    ? getUsageStatus(claudeCode.fiveHourWindow.percentage)
    : 'normal';
  // ... rest of component
```

2. Update the render to pass `isLoading` and use local state:

```typescript
  return (
    <div className={/* ... existing className logic */}>
      {/* Claude Code Section */}
      <ClaudeCodeSection data={claudeCode} isLoading={isLoading} />

      {/* Error display */}
      {error && (
        <div className="px-4 pb-2 text-xs text-accent-warning">
          {error} - showing sample data
        </div>
      )}

      {/* API Credits Section */}
      {showApiSection && (
        <>
          <div className="border-t border-gray-200" />
          <ApiCreditsSection data={apiCredits} />
        </>
      )}
    </div>
  );
```

**Verification:** Widget loads and displays real usage data on mount.

---

### Task 7: Handle edge cases and empty states
**File:** `server/claude-usage.ts` (APPEND)

Add handling for various edge cases:

```typescript
// Add at the start of getClaudeCodeUsage function:

// Check if Claude directory exists
const projectsDir = getClaudeProjectsDir();
if (!fs.existsSync(projectsDir)) {
  return createEmptyUsageResponse(plan, 'Claude data directory not found');
}

// Check if project directory exists
const projectDirPath = path.join(projectsDir, projectDirName);
if (!fs.existsSync(projectDirPath)) {
  return createEmptyUsageResponse(plan, 'No Claude data for this project');
}

// Helper function for empty response
function createEmptyUsageResponse(plan: ClaudePlanTier, message?: string): ClaudeCodeUsage {
  return {
    plan,
    fiveHourWindow: {
      used: 0,
      limit: CLAUDE_USAGE_CONFIG.planLimits[plan],
      percentage: 0,
      resetsAt: new Date(Date.now() + 5 * 60 * 60 * 1000).toISOString(),
      resetsIn: '5h 0m',
    },
    today: { tokens: 0, estimatedCost: 0, sessions: 0 },
    monthToDate: { tokens: 0, estimatedCost: 0, sessions: 0 },
    modelBreakdown: [],
    lastUpdated: new Date().toISOString(),
    dataSource: 'local-files',
    _message: message, // Optional debug message
  };
}
```

**Verification:** Call with non-existent project path, verify graceful fallback.

---

## Verification

After completing all tasks, verify:

1. **Backend endpoint works:**
   ```bash
   curl http://localhost:4000/api/claude-usage/code | jq
   ```

2. **Response matches interface:**
   ```typescript
   {
     plan: 'pro',
     fiveHourWindow: { used, limit, percentage, resetsAt, resetsIn },
     today: { tokens, estimatedCost, sessions },
     monthToDate: { tokens, estimatedCost, sessions },
     modelBreakdown: [...],
     lastUpdated: '...',
     dataSource: 'local-files',
     queriedAt: '...'
   }
   ```

3. **Widget displays real data:**
   - Open dashboard
   - ClaudeUsageCard shows actual token counts
   - Model breakdown reflects real usage by model
   - 5-hour window percentage updates correctly

4. **TypeScript compilation:**
   ```bash
   npm run build
   ```

## Success Criteria

- [ ] `server/claude-usage.ts` created with JSONL parsing utilities
- [ ] 5-hour window calculation correctly filters and aggregates tokens
- [ ] Model breakdown groups usage by opus/sonnet/haiku
- [ ] Cost estimation uses pricing from config file
- [ ] `/api/claude-usage/code` endpoint returns valid ClaudeCodeUsage
- [ ] MCPClient has `getClaudeCodeUsage()` method
- [ ] ClaudeUsageCard fetches and displays real data
- [ ] Empty/error states handled gracefully
- [ ] TypeScript compiles without errors

## Output

**Files created:**
- `server/claude-usage.ts` (NEW) - JSONL parsing and aggregation logic

**Files modified:**
- `server/index.ts` (MODIFIED) - Added /api/claude-usage/code endpoint
- `src/services/mcp-client.ts` (MODIFIED) - Added getClaudeCodeUsage method
- `src/components/a2ui/ClaudeUsageCard.tsx` (MODIFIED) - Connected to real data

**Next phase:** Phase 3 - API Credits Section (Admin API integration, manual entry)
