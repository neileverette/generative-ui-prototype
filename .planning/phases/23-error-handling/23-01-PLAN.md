---
phase: 23-error-handling
plan: 01
type: execute
domain: scraper
---

<objective>
Implement exponential backoff retry strategy and circuit breaker pattern for transient failures in the Claude Console scraper. Transform the current simple error counter (stops after 3 failures) into intelligent retry logic that distinguishes between recoverable errors requiring backoff vs fatal errors requiring immediate exit.

**Purpose:** Improve scraper resilience against transient network issues and rate limiting while avoiding wasted retry attempts on fatal errors.

**Output:** Auto-scraper with exponential backoff, jitter, circuit breaker, and graceful degradation when partial data is available.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary-template.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-session-management-authentication/22-01-SUMMARY.md
@.planning/phases/22-session-management-authentication/22-02-SUMMARY.md
@server/claude-scraper/auto-scraper.ts
@server/claude-scraper/scrape.ts
@server/claude-scraper/session-validator.ts

**Tech stack available:**
- Playwright for browser automation
- TypeScript with ESM modules
- Node.js promisify for async exec

**Established patterns from Phase 22:**
- Error categorization (SESSION_EXPIRED, NETWORK_ERROR, CONTEXT_CORRUPTED, UNKNOWN)
- Immediate exit on fatal errors (session/context issues)
- Verbose logging with --verbose flag
- Session age tracking

**Constraining decisions:**
- Phase 22: Exit immediately on SESSION_EXPIRED and CONTEXT_CORRUPTED (no retry)
- Phase 22: Auto-recovery only for soft session expirations
- Phase 22: Error messages include category prefix and specific action guidance

**Current state:**
- Auto-scraper has basic error counter (consecutiveErrors, MAX_ERRORS = 3)
- No backoff between retries (immediate retry on next 5-minute interval)
- No distinction between recoverable vs fatal errors for retry logic
- No circuit breaker to prevent repeated failures
- No graceful degradation (all-or-nothing data extraction)

**Phase 23 goal from roadmap:**
Add comprehensive error handling with intelligent retry logic. Implement exponential backoff, distinguish recoverable vs fatal errors, circuit breaker pattern, and graceful degradation when partial data is available.
</context>

<tasks>
<task type="auto">
  <name>Task 1: Create retry strategy module with exponential backoff</name>
  <files>server/claude-scraper/retry-strategy.ts</files>
  <action>
Create a new retry-strategy.ts module that implements:
1. RetryConfig interface with maxAttempts, baseDelayMs, maxDelayMs, jitterFactor
2. RetryStrategy class with:
   - calculateDelay(attemptNumber): Exponential backoff with jitter
   - shouldRetry(error, attemptNumber): Determines if error is recoverable and attempts remain
   - recordAttempt(): Tracks retry attempts
   - reset(): Resets retry state
3. Error classification:
   - Recoverable: NETWORK_ERROR (timeout, connection reset, DNS failure)
   - Fatal: SESSION_EXPIRED, CONTEXT_CORRUPTED, UNKNOWN (immediate exit, no retry)
4. Exponential backoff formula: delay = min(baseDelay * 2^attempt + random(0, jitter), maxDelay)
5. Default config: baseDelay 30s, maxDelay 5min, maxAttempts 5, jitter 0-10s

DO NOT use external retry libraries (p-retry, async-retry) - implement natively to avoid dependencies and maintain full control over error classification.

Export RetryStrategy class and RetryConfig interface for use in auto-scraper.
  </action>
  <verify>TypeScript compiles without errors. Module exports RetryStrategy class and RetryConfig interface. calculateDelay() returns increasing delays with jitter for attempts 1-5.</verify>
  <done>retry-strategy.ts created with exponential backoff, jitter, error classification, and configurable retry limits. No external dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate retry strategy into auto-scraper</name>
  <files>server/claude-scraper/auto-scraper.ts</files>
  <action>
Modify auto-scraper.ts to use RetryStrategy:
1. Import RetryStrategy and create instance with defaults at module level
2. Replace consecutiveErrors counter with retryStrategy state
3. In catch block, use shouldRetry() to determine if retry is appropriate:
   - If shouldRetry() returns false → Exit immediately (fatal or max attempts)
   - If shouldRetry() returns true → Calculate delay, log next retry time, schedule retry
4. Add immediate retry scheduling on recoverable errors:
   - Call calculateDelay() to get backoff duration
   - Use setTimeout() to schedule retry after backoff (not next 5-min interval)
   - Log: "[Auto-Scraper] Recoverable error. Retrying in Xs..." (show calculated delay)
5. Reset retry state on successful scrape (after consecutiveErrors = 0 line)
6. Preserve existing behavior:
   - Exit immediately on SESSION_EXPIRED, CONTEXT_CORRUPTED
   - Show error category and specific action in error messages
   - Verbose logging with --verbose flag
7. Update error messages to show retry attempt number and max attempts

DO NOT change the 5-minute interval for successful scrapes. Only apply backoff to error retries.
  </action>
  <verify>npm run build succeeds. Auto-scraper logs show retry attempt numbers, calculated backoff delays, and exits after 5 failed attempts or on fatal errors. No TypeScript errors.</verify>
  <done>Auto-scraper uses exponential backoff for NETWORK_ERROR retries. Fatal errors (SESSION_EXPIRED, CONTEXT_CORRUPTED) exit immediately. Successful scrapes reset retry state and continue 5-minute interval.</done>
</task>

<task type="auto">
  <name>Task 3: Add circuit breaker pattern to prevent repeated failures</name>
  <files>server/claude-scraper/retry-strategy.ts, server/claude-scraper/auto-scraper.ts</files>
  <action>
Add circuit breaker to RetryStrategy:
1. Add CircuitState enum: CLOSED (normal), OPEN (failing), HALF_OPEN (testing recovery)
2. Add circuit breaker state tracking:
   - failureThreshold: 3 consecutive failures → OPEN
   - successThreshold: 2 consecutive successes in HALF_OPEN → CLOSED
   - openDuration: 60s before attempting HALF_OPEN
3. Add methods:
   - recordSuccess(): Decrements failure count, transitions OPEN→HALF_OPEN→CLOSED
   - recordFailure(): Increments failure count, transitions CLOSED→OPEN
   - isCircuitOpen(): Returns true if OPEN and openDuration not elapsed
   - getCircuitState(): Returns current state for logging
4. Update shouldRetry():
   - Return false if circuit is OPEN (prevents retries during cool-down period)
   - Allow retries in CLOSED and HALF_OPEN states
5. In auto-scraper.ts:
   - Call recordSuccess() on successful scrape
   - Call recordFailure() before shouldRetry() check
   - Check isCircuitOpen() before attempting scrape
   - Log circuit state changes with --verbose flag
   - Show circuit state in error messages when OPEN

This prevents hammering the Console during extended outages and gives time for issues to resolve.
  </action>
  <verify>TypeScript compiles. Circuit opens after 3 failures, waits 60s, tries HALF_OPEN, closes after 2 successes. isCircuitOpen() prevents scrape attempts during cool-down.</verify>
  <done>Circuit breaker implemented with CLOSED/OPEN/HALF_OPEN states. Opens after 3 failures, waits 60s, tests recovery, closes after 2 successes. Auto-scraper respects circuit state.</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript builds without errors (npm run build)
- [ ] retry-strategy.ts exports RetryStrategy class with exponential backoff
- [ ] Auto-scraper uses RetryStrategy for error handling
- [ ] Fatal errors (SESSION_EXPIRED, CONTEXT_CORRUPTED) exit immediately
- [ ] Recoverable errors (NETWORK_ERROR) retry with exponential backoff
- [ ] Circuit breaker opens after 3 failures, closes after recovery
- [ ] Successful scrapes reset retry state and continue 5-minute interval
- [ ] Verbose logging shows retry attempts, delays, and circuit state
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors or warnings
- Auto-scraper handles transient network failures with intelligent backoff
- Circuit breaker prevents repeated failures during extended outages
- Fatal errors still exit immediately (no regression from Phase 22)
- Retry logic is configurable via RetryConfig interface
</success_criteria>

<output>
After completion, create `.planning/phases/23-error-handling/23-01-SUMMARY.md` following the standard template:

```markdown
---
phase: 23-error-handling
plan: 01
subsystem: scraper
tags: [error-handling, retry-logic, circuit-breaker, resilience]
requires: [22-01, 22-02]
provides: [exponential-backoff, circuit-breaker, intelligent-retry]
affects: [24, 25, 26]
tech-stack:
  added: []
  patterns: [exponential-backoff, circuit-breaker, retry-with-jitter]
key-files:
  created:
    - server/claude-scraper/retry-strategy.ts
  modified:
    - server/claude-scraper/auto-scraper.ts
key-decisions:
  - [List decisions made during implementation]
issues-created: []
metrics:
  duration: [actual duration]
  completed: [completion date]
---

# Phase 23 Plan 1: Retry Strategy & Circuit Breaker Summary

**[One-line summary of what was accomplished]**

## Accomplishments

[Detailed description of retry strategy implementation]

## Files Created/Modified

[List with line counts and key functionality]

## Technical Details

[Exponential backoff formula, circuit breaker states, error classification]

## Commits

[List of commits with hashes]

## Decisions Made

[Any implementation choices or tradeoffs]

## Issues Encountered

[Problems and resolutions]

## Next Step

[What comes next - either 23-02 or Phase 24]
```
</output>
